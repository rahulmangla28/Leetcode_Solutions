#include <vector>
#include <unordered_map>
#include <algorithm>

class DSU {
public:
    DSU(int N) {
        p.resize(N);
        sz.resize(N, 1);
        for (int i = 0; i < N; i++) {
            p[i] = i;
        }
    }
    
    int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
    
    void unionBySize(int x, int y) {
        int xr = find(x);
        int yr = find(y);
        p[xr] = yr;
        sz[yr] += sz[xr]%1000000007;
        sz[yr] %= 1000000007;
    }

    int size(int x) {
        return sz[find(x)];
    }
    
private:
    std::vector<int> p;
    std::vector<long long int> sz;
};

class Solution {
public:
    int minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial) {
        DSU dsu(graph.size());
        for (int j = 0; j < graph.size(); j++) {
            for (int i = 0; i < j; i++) {
                if (graph[j][i]) {
                    dsu.unionBySize(i, j);
                }
            }
        }
        std::unordered_map<int, int> count;
        for (int u : initial) {
            count[dsu.find(u)]++;
        }
        std::pair<int, int> ans = {-1, *std::min_element(initial.begin(), initial.end())};
        for (int node : initial) {
            int root = dsu.find(node);
            if (count[root] == 1) {
                if (dsu.size(root) > ans.first) {
                    ans = {dsu.size(root), node};
                } else if (dsu.size(root) == ans.first && node < ans.second) {
                    ans = {dsu.size(root), node};
                }
            }
        }
        return ans.second;
    }
};
